\section{Dynamic Scheduling}

\begin{parag}{Starting point}
    As we have seen before, processor has first been \important{sequential multicycle processor}. Now we wanted to replace it with something else: \important{pipelined processor}.
	\begin{center}
	\includegraphics[scale=0.2]{screenshots/2025-12-03.png}
	\end{center}
	For instance, 5-stage pipeline with all forwarding paths. Typical of \important{MIPS} and \important{RISC-V}.
	The issue with this is that \important{all instructions} has to go through \important{all the stages} $\implies$ we need a very small ISA (MIPS, RISC-V).
	The other issue is that pipelined need \important{independence}. Every circuits in each stage has to be used \important{only in that stage}.
	This is the simplest form of \important{Instruction Level Parallelism} (ILP): several instructions are now executed at once.
\end{parag}
\begin{parag}{Simple Pipelining}
    The scope if \important{parallelism is limited}:
	\begin{itemize}
		\item \important{Data hazards} limit the usability of the pipeline:
			\begin{itemize}
				\item Whenever the next instruction cannot be executed, the pipeline is stalled and no new useful work is done until the 'problem' is solved (e.g., cache miss)
			\end{itemize}
		\item \important{Control hazards} limit the usability of the pipeline
			\begin{itemize}
				\item Must squash fetched and decoded instruction followig a branch
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{parag}

\begin{parag}{Rigid Sequencing}
    \begin{itemize}
		\item Special 'slots' for everything even if sometimes useless (e.g. M)
		\item Every instruction must be \important{coerced to the same framework} (floating point vs. integer)
		\item Structural hazards avoided 'by construction'
    \end{itemize}
	This means that if we need some floating point arithmetic then we are a bit lost on our RISC processor. We would need to implement the floating point in software (which is slower).
\end{parag}

\paragraph{Dynamic Scheduling: The Idea}%
\label{par:Dynamic Scheduling: The Idea}
Let us for instance take a look at the code:
% \begin{lstlisting}[language={{RISC-V}Assembler}]
% divd $f0, $f2, $f4
% addd $f10, $f0, $f8
% subd $f12, $f8, $f14
% \end{lstlisting}
Here the instruction \texttt{divd} is a long-running instruction which hurt our feeling...it makes our program \important{stalls} for the next instruction \texttt{add f10, f0, f8} which need the value \texttt{f0}. However as we can see the instruction \texttt{subd} is completely independent of the two above. As we have seen before, maybe a way of resolving the stalling is by using a 'smart' compiler which would put the \texttt{subd} instruction between those two. However here our \texttt{divd} takes a long time but how much? how many cycles? We cannot know right? Imagine having a \texttt{load} instruction we wouldn't even know!
\begin{theoreme}
Relax a fundamental rule: instructions can be executed \important{out of program order} (but the result must still be \important{correct}).
\end{theoreme}

\begin{parag}{Break the Rigidity of the Basic Pipelining}
    For us we need:
	\begin{itemize}
		\item \important{Continue fetching and decoding} even and especially if one cannot exevcute previous instructions
		\item \important{Keep writeback waiting} if there is a structural hazard, without slowing down execution.
	\end{itemize}
\end{parag}
\begin{parag}{Solution}
    The solution here is the \important{splits the tasks} in independent units/pipelines
	\begin{itemize}
		\item \important{Fetch and Decode}
		\item \important{Execute}
		\item \important{Writeback}
	\end{itemize}
\end{parag}
\begin{parag}{Dynamically Scheduled Processor}
	So now the we don't have to go through one big pipeline. Now we break our previous big pipeline into smaller pipeline. We may have a big pipeline for floating point double and a smaller one for 32 bits floating point. 
    \begin{center}
    \includegraphics[scale=0.2]{screenshots/2025-12-03_1.png}
    \end{center}
	So what is going here is we create a big Execution unit with all the possible instruction (memory, alu, etc.). We then wire them back into our decode just as we did before. Now everything that produce a result we bring it back \important{where} there is a possible use of it.
	
\end{parag}
\begin{framedremark}
Here what we have is still a finite state machine. The reason why we don't present it as one is that the number of state that is can have is enormous. It the a combinatorial calculation between all the state F, D, E/M1, .., W.
\end{framedremark}

\subsubsection{Problems to solve}
Now we have a kind of big work to do, all the previous issues that we had already solved come back again at us here:
\begin{parag}{Structural Hazards}
	\begin{itemize}
		\item Are the required resources available?
		\item New problem: previously handled by rigid pipeline
	\end{itemize}
\end{parag}
\begin{parag}{RAW Data Hazards}
    \begin{itemize}
		\item Are the operands ready to start execution
		\item Old problem
    \end{itemize}
\end{parag}
\begin{parag}{WAR and WAW Data Hazards}
	\begin{itemize}
		\item The new data overwrite something which is still requires?
		\item WAW is a completely new problen -- impossible before, WAR often cannot occur
	\end{itemize}
\end{parag}

\begin{parag}{Raw Data Hazards}
    Let us start with this one. This problem comes fron the \texttt{RS} register from the previous picture. Maybe what we read the register and the value from it is false. We want  to erase it. The solution here is to use a \important{Reservation Station}
\end{parag}
\begin{parag}{Reservation Station}
	\begin{definition}[Reservation station]
	checks that the \important{operands are available} (RAW) and that the \important{Execution Unit is free} (Structural Hazards), then starts execution.
	\end{definition}
    \begin{center}
    \includegraphics[scale=0.2]{screenshots/2025-12-03_2.png}
    \end{center}
	So here for instance the \texttt{ALU3} means that the value we are waiting for will be the result of the \texttt{ALU3} instruction im the reservation stations.
	\begin{subparag}{The parking lot}
	    We can see our Reservation stations as a \important{parking lot} instead of having car we have instructions waiting to be ready. Everytime one is ready then we launch it. This is a completely \important{unordered} 'data structure'.
		On the bottom we have a ALU that is ready to compute something \important{every cycles}.
		On the top then we have all the come back pipe which comes to us and tell for intsnace 'I am the result of the MUL3 computation' we then ask ourself if any of us (instructions) is waiting for the \texttt{MUL3} result.
	\end{subparag}
\end{parag}
\begin{center}
    
\scalebox{0.7}{
\begin{tikzpicture}[
    node distance=2cm,
    box/.style={
        draw,
        minimum width=6cm,
        minimum height=2.5cm,
        align=center,
        fill=red!20
    },
    textnode/.style={
        align=center,
        text width=6cm
    },
    >=Stealth
]

% Reservation Station box
\node[box] (RS) {Reservation Station};

% Top-left text
\node[textnode, above left=1.7cm and -0.3cm of RS] (FD) {
    \textbf{\underline{Fetch\&Decode Unit and Register File}} \\
    (1) Fetched operation descriptions and \\
    (2a) known operands (from RF) \\
    or (2b) source-operation tags
};

% Top-right text
\node[textnode, above right=1.7cm and -0.3cm of RS] (EU) {
    \textbf{\underline{All Execution Units}} \\
    (1) Tags of the executed operations \\
    and (2) corresponding results
};

% Bottom text
\node[textnode, below=2cm of RS] (DEU) {
    \textbf{\underline{Dependent Execution Unit}} \\
    (1) Description of operations ready to execute \\
    with (2) corresponding tags and (3) operands
};

% Arrows
\draw[->, thick] (FD) -- (RS);
\draw[->, thick] (EU) -- (RS);
\draw[->, thick] (RS) -- (DEU);

\end{tikzpicture}
}



\end{center}

\begin{parag}{What is a Reservation Station?}
A \important{reservation station} is a small buffer inside the processor that holds
instructions after they have been decoded but \important{before} they are executed.
Its purpose is to allow the CPU to execute instructions \textbf{out of order}
without violating the correctness of the program.

A reservation station entry contains:
\begin{itemize}
    \item the \textbf{operation} to execute (e.g.\ \texttt{add}, \texttt{mul}), 
    \item the \textbf{operands}, if they are already available,
    \item or \textbf{tags} indicating that the operand is not available yet,
    \item and the \textbf{destination tag} where the result must later be written.
\end{itemize}

The idea is simple: an instruction does \important{not} need to wait for its
operands in the decode stage. Instead, it is placed in a reservation station
entry, even if some operands are missing. The entry then ``listens'' to all
execution units. Whenever a unit finishes and broadcasts a result together with
its tag, each reservation station checks whether it was waiting for that value.

If an entry collects \important{all} its operands, then that instruction is marked
as \textbf{ready}. As soon as the corresponding execution unit becomes free,
the reservation station dispatches the instruction to it.

In short:
\begin{itemize}
    \item It solves \textbf{RAW hazards} by waiting for the true operands.
    \item It helps avoid \textbf{structural hazards} by checking that the execution unit is free.
    \item It enables \textbf{out-of-order execution}: instructions no longer need to
          wait in program order if they already have what they need.
\end{itemize}

A reservation station therefore acts as a \important{smart waiting room} for
instructions: they enter as soon as they are decoded, wait only for the data
they require, and are issued to execution as soon as they are ready.
\end{parag}
So here our read after write issue is gone. But the WAR or WAW are not resolved. The question the Prof. asked was:
\begin{center}
    Why don't we use something simpler for our tag (e.g., the register name)?
\end{center}
Our register are not unique, this would work only if we were in an ordered program where each instruction are followed by the next one. If that was the case then yes this would work because as the register t4 we would have the latest value of t4 which is the one we need.
But what happens if we are in an unordered instruction table (Reservation stations)? Then in that case it could be possible that there is a previous value that is not the correct one in t4, t4 would not be unique.

We need \important{unicity} we have to be sure that when calling a tag then the value of this tag \important{has to be unique}.

So why don't we use the program counter as a tag? By using it then we have a unique identifier for each value right? But what if we have a loop, then for the same pc we would still have two different values.

\begin{parag}{WAW and WAR}
    Those hazard were not really possible in a simple pipeline (by construction). However here this is different, for instance:
	\begin{center}
	\includegraphics[scale=0.2]{screenshots/2025-12-03_4.png}
	\end{center}
	So here we have a new issue. The solution for this would be for instance to rename our register like:
	Given this code
	\begin{lstlisting}[language={{RISC-V}Assembler}]
divd f0, f1, f2 
addd f3, f0, f4 
subd f4, f5, f6  #create issue with the f4 of the previous instruction
adddi f0, f4, 10 #create issue with the f4 of the previous instruction
	\end{lstlisting}
	We can change it to:
\begin{lstlisting}[language={{RISC-V}Assembler}]
divd f0, f1, f2 
add f3, f0, f4 
subd f30, f5, f6 
f29, f30, 10
\end{lstlisting}
	But here our reservation station comes down pretty much as renaming each register as the tag.
	\begin{itemize}
	   \item Unavailable operands are identified by the \important{name of the reservation station} in charge of the originating instruction
	   \item \important{Implicit register renaming}, thus removing WAR and WAW hazards
	   \item New results are seen at their inputs through special result bus(es)
	   \item Writeback into the registers can be in-order or, to some extent, out-of-order
	\end{itemize}
\end{parag}

\subsection{Dynamically Scheduled Processor}
So here what we get at the end is:
\begin{center}
\includegraphics[scale=0.3]{screenshots/2025-12-03_5.png}
\end{center}
What we here as an issue still is how do we know where to write in the register file, we need to be careful about our ordering in our register file. This is the commit unit's job.
\begin{parag}{Our-of-order Commitment and Exceptions}
	\begin{itemize}
		\item Excpetion handlers should know exaclty where a problem has occured, especially for \important{nonterminating exceptions} (e.g., page fault)
		\item Of course, one assumes that everything before the faulty instruction was executed and everything after was not
		\item With dynamic execution it might no longer be true...
	\end{itemize}
\end{parag}
\begin{parag}{Problems with exceptions}
    Now we have an issue again with excpetions:
	\begin{subparag}{Precise exceptions}
	    Reordering at commit; user view is that of a fully in order processor
		\begin{lstlisting}[language={{RISC-V}Assembler}]
andi t4, t2, 0xff # good code
andi t5, t4, 0xff # good code
addi v0m t5, 1  # good code
srl t2, t2, 8 # good code
-> lw t3, 8(t6) # now we have our exception
andi t4, t3, 3  # bad code
addi t0, t0, 4 # bad code
addi t1, t1, 4 # bad code
		\end{lstlisting}
		So now we need to come back from where were at the exception. To do so we need to save the pc of where the exception has happened we already have it and returning to it is already implemented (the \texttt{ret} in RISC-V).
		
	\end{subparag}
	\begin{subparag}{Imprecise exceptions}
		\begin{itemize}
			\item No reordering; out-of-order completion visible to the user
			\item The OS/programmer must be aware of the problem and take appropriate action (e.g., execute again the complete subroutine where the problem occured)
		\end{itemize}
		\begin{lstlisting}[language={{RISC-V}Assembler}]
andi t4, t2, 0xff # good code
andi t5, t4, 0xff # bad code
addi v0m t5, 1  # bad code
srl t2, t2, 8 # good code
-> lw t3, 8(t6) # now we have our exception
andi t4, t3, 3  # bad code
addi t0, t0, 4 # good code
addi t1, t1, 4 # bad code
		\end{lstlisting}
		Now here we are not able to jump again, if we were, yes our program would run again fine but then that addi here has already been computed (\texttt{addi t0, t0, 4}) would be refetched again which would make our \texttt{to} incremented two times!
	\end{subparag}
\end{parag}
\begin{parag}{Reorder Buffer}
    The way of solved this issue is to add a new buffer between the output and the register file:
	\begin{center}
	\includegraphics[scale=0.3]{screenshots/2025-12-03_6.png}
	\end{center}
	This one is pretty different from the other buffer. This one \important{has to be ordered}. This buffer works kind of like our pipeline registers.\\
	Now this buffer \important{has to know where the instruction where}. And it also need to know where, what who, etc. So here this is not like the previous parking lot, the order now is important. The purpose of this unit is to make the user believe that everything is sequential.
	\begin{framedremark}
	For this part (the example the video is always better than this so this is \textit{cs-200 -- 4d. Instruction Level Parallelism (cont'd) around 20:00}) But I will still try:
	\end{framedremark}
\end{parag}
\begin{parag}{Example}
	Let us take for example the following reorder table. As we can see with have an head and a tail. The head represent the element which has the smallest \texttt{pc}.
    \begin{center}
    \includegraphics[scale=0.2]{screenshots/2025-12-10_1.png}
    \end{center}
	So firstly we check the first lane that is at the head: \texttt{0|0x100 0004|  |\$ f3|  |0x627fba5a}. As we can see ther eis no tag or anything that we need to wait for \textrightarrow we can commit the instruction!
	\begin{center}
	\includegraphics[scale=0.2]{screenshots/2025-12-10_3.png}
	\end{center}
	Now this is different: we currenlty don't have the value. We need to wait until the oldest instruction here has its result. As soon has it has the value, then we can write to the memory the value.
\end{parag}

\begin{parag}{Reordering and Precise Exceptions}
	However here we still have the big issue of \important{exceptions}:\\
	So we need some extra bits in the reorder buffer to know wehter or not there is an exception on a given instruction. Okay this is nice now we know when an instruction happens but what should we do?\\

	So now we can always execute the previous instruction without having to worry about anything right? But what happens when the head is on the exception pc?
	\begin{itemize}
		\item  When a synchronous exceptions happens, we do no report it but we \important{mark the entry} corresponding to the instruction which caused the exception in the ROB
		\item When we would be ready to \important{commit} the instruction, we \important{raise the exception} instead
		\item We also \important{trash} the content of the ROB and all RSs
	\end{itemize}
\end{parag}
\begin{parag}{Example}
	\begin{center}
	\includegraphics[scale=0.2]{screenshots/2025-12-10_4.png}
	\end{center}
	So here what happened here is that we tried to store the value out of the \textbf{MEM1} unit which result in a TLB miss \textrightarrow we simply \important{record the exception}. Now we can still execute the instruction that is at the address \texttt{0x1000 0004} as nothing has happenend.
	\begin{center}
	\includegraphics[scale=0.2]{screenshots/2025-12-10_5.png}
	\end{center}
	Now that we are on the current instruction, we \important{need to actually to notify} the world about our problem. We can now raise out tlb Miss exception. But all the thing that we had computed before is rubbish, we cannot know if those value are actually correct or just something that were computed with the wrong values, to solve this issues, we just \important{erase} everything that were in the reorder buffer.
    
\end{parag}

\begin{parag}{Problem we need to solve?}
	The structural hazards were not an issue here, the \important{reservation stations} take care of the contention for execution units. The \important{commit unit} writes back one instruction at a time.\\
	But what about RAW Data hazards,  but those are taken care of by the \important{reservation stations}
\end{parag}
\begin{parag}{Reservation stations}
    We said as before that: as the decode unit, we get an instruction, if the input are available then we put the arguement and the op etc\ldots of the instruction in the reservation stations, else, we put the tag of the instruction... 
	\begin{center}
	    How do we know?
	\end{center}
	This is the decode unit problem, the decode unit has to know if the parameter is available, but how can he know. He receive an instruction like "add the register x2 and the register x4" but how can he knows if he can read the value or not?\\
	Before, what we used to do is to check in the past. In a simple pipeline processor the 'past' is actually on the 'right' of the pipeline, we can check if any instruction on the right of the pipeline has as output one of the register we currenlty have, if yes then we know that we have to wait. Can we do something like this now?\\
\end{parag}
\begin{parag}{Decoding and Dependence}
    \begin{center}
        The \important{reorder buffer (ROB)} knows of all instructions not yet committed and of their desitnation registers
    \end{center}
	\begin{subparag}{Possible situations}
	    \begin{itemize}
	        \item \important{No dependence} \textrightarrow Read the \important{value} from the \texttt{RF}
	        \item \important{Dependence} from an ongoing instruction 
				\begin{itemize}
					\item If the value is already computed \textrightarrow Get the \important{value} from the \important{ROB}
					\item If the value is not yet computed \textrightarrow Get the \important{tag} from the \important{ROB} 
				\end{itemize}
	    \end{itemize}
	    
	\end{subparag}
    
\end{parag}


\begin{parag}{Dependences through memory}
    The way we detect and resolve dependences through memory (a store at some address and a subsequent load from the same address) is the same as for registers\\
	For every load, check the ROB:
	\begin{itemize}
		\item If there is \important{no store to the same address} in the ROB, get the value from memory (i.e., from the cache)
		\item If there is a \important{store to the same address} in the ROB, either get the value (if ready) or the tag
			\begin{center}
			    \textbf{But there is an additional situation now}
			\end{center}
		\item If there is a store to an \important{unknown address} in the ROB or if the address of the load is unknown, \important{wait}
	\end{itemize}
	\begin{framedremark}
	The memory and the register file comes down to the same thing, conceptually we have to do the same thing for both.\\
	The slide difficulty for the implementation of the memory is: when we are looking for a certain register we only have to check ('is there an \texttt{f1} here?'). When we wont to write something, it can happen that the address is not ready yet. So when we want to read at a certain address, but there were a write before at an unknown address, we just cannot know if the value at the certain address will be overwrite or not?
	\end{framedremark}
	The solution for this is to use a Load store queue:
\end{parag}
\begin{parag}{Load-Store Queue}
	In practice, the \important{memory part of the ROB} is implemented separately and is called a \important{Load-Store Queue} (in turn, usually implemented as a Load and a Store queues)
    \begin{center}
    \includegraphics[scale=0.2]{screenshots/2025-12-10_6.png}
    \end{center}
\end{parag}



\begin{parag}{Second Step: Dynamic Scheduling}
    So here this is where we are at:
	\begin{center}
	\includegraphics[scale=0.2]{screenshots/2025-12-10_7.png}
	\end{center}
	We gain to ability to reorder instructions \textrightarrow \important{unlocks a tangible amout of ILP}
	\begin{subparag}{Is it easy to implement?}
	    The question the professor asked is:
		\begin{center}
		    Is it easy to implement (in verilog for example)
		\end{center}
		Let's take for instance the Reservation Stations, How do we size the table:
		\begin{itemize}
			\item If we take a smaller size, it block \textrightarrow we are dead
			\item The second level of problem is: what is the best number?\\
				Taking 32 or 16 maybe doesn't change the result but which one is the best for us?
		\end{itemize}
		The way of doing this is experiment right? we can try to simulate our processor to see which size is the best!\\
		But at the end the reservation stations maybe just be a piece of memory right? But The sad thing here is: we have to search everytime we received a new element then we have to check every element if they care or not.
		Also, we have \important{all the data buses} such as the F and D unit, the EUs and RF which gives information to our reservation stations. all of those big buses has to be 'concentrated' into a couple of flipflop. We have the same issue for the reorder buffer, we have also to search in our big buffer
	\end{subparag}
\end{parag}
\paragraph{Summary: ILP So Far}%
\label{par:Summary: ILP So Far}
\begin{center}
\includegraphics[scale=0.2]{screenshots/2025-12-10_8.png}
\end{center}
How we have seen the reorder buffer and the reservation stations, with the tag that is stored inside the buffer is a pretty naive way of seeing it. Yes it works, but is it practical? Not really



